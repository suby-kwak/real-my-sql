# 4. 아키텍처

## 4-1. MySQL 엔진 아키텍처

### 4-1-1. MySQL의 전체 구조
#### 4-1-1-1. MySQL 엔진
요청된 SQL 문장을 분석하거나 최적화하는 역할

| 구성요소 | 역할 |
|---------|------|
| 커넥션 핸들러 | 클라이언트 접속 처리 |
| SQL 파서 | 쿼리 문장 분석 |
| 전처리기 | 구조적 문제 확인 |
| 옵티마이저 | 쿼리의 최적화된 실행 |

#### 4-1-1-2. 스토리지 엔진
실제 데이터를 스토리지에 저장하거나 읽어오는 역할

- MySQL 엔진은 하나, 스토리지 엔진은 여러 개 사용 가능
- 테이블 생성 시 스토리지 엔진 지정: `CREATE TABLE ... ENGINE=INNODB;`
- 각 스토리지 엔진별 성능 향상 기능
  - **MyISAM**: 키 캐시
  - **InnoDB**: InnoDB 버퍼 풀

#### 4-1-1-3. 핸들러 API
쿼리 실행기에서 데이터를 쓰거나 읽을 때, 각 스토리지 엔진에 쓰기/읽기를 요청하는 API

---

### 4-1-2. MySQL 스레딩 구조

#### 4-1-2-1. 포그라운드 스레드 (클라이언트 스레드)
- 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
- 커넥션 종료 시 담당 스레드는 캐시로 돌아감
- 스레드 캐시에 대기 중인 스레드가 충분하면 종료

**스토리지 엔진별 차이**

| 엔진 | 처리 범위 |
|-----|----------|
| MyISAM | 디스크 쓰기 작업까지 포그라운드에서 처리 |
| InnoDB | 데이터 버퍼/캐시까지만 처리, 디스크 기록은 백그라운드 |

#### 4-1-2-2. 백그라운드 스레드
MyISAM은 해당사항 없음. InnoDB에서 처리하는 작업:

1. 인서트 버퍼 병합
2. 로그를 디스크로 기록
3. InnoDB 버퍼 풀 데이터를 디스크에 기록
4. 데이터를 버퍼로 읽기
5. 잠금/데드락 모니터링

> **핵심 원칙**: 쓰기 작업은 지연 가능, 읽기 작업은 절대 지연 불가
>
> - InnoDB: 쓰기 작업을 버퍼링해서 일괄 처리 (데이터 변경 시 파일 저장 완료를 기다리지 않아도 됨)
> - MyISAM: 쓰기 버퍼링 기능 없음

---

### 4-1-3. 메모리 할당 및 사용 구조

#### 4-1-3-1. 글로벌 메모리 영역
클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당

- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

#### 4-1-3-2. 로컬 메모리 영역 (세션 메모리 영역)
클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역

- 각 스레드별로 독립적으로 할당, **절대 공유되지 않음**

| 유형 | 버퍼 | 할당 시점 |
|-----|------|----------|
| 상시 할당 | 커넥션 버퍼, 결과 버퍼 | 커넥션이 열려있는 동안 유지 |
| 임시 할당 | 소트 버퍼, 조인 버퍼 | 쿼리 실행 순간에만 할당 후 해제 |

로컬 메모리 종류: 정렬 버퍼, 조인 버퍼, 바이너리 로그 캐시, 네트워크 버퍼

---

### 4-1-4. 플러그인 스토리지 엔진 모델

- 마지막 '데이터 읽기/쓰기' 작업만 처리
- MySQL 엔진이 스토리지 엔진에게 명령하려면 **반드시 핸들러를 통해야 함**

> ⚠️ **중요**: 하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데, 각 하위 작업이 MySQL 엔진 영역에서 처리되는지 스토리지 엔진 영역에서 처리되는지 구분할 줄 알아야 한다.

---

### 4-1-5. 컴포넌트 (MySQL 8.0+)
기존 플러그인 아키텍처를 대체

**플러그인의 단점**
1. 플러그인은 오직 MySQL 서버와만 인터페이스 가능, 플러그인끼리 통신 불가
2. MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음
3. 상호 의존 관계를 설정할 수 없어서 초기화가 어려움

---

### 4-1-6. 쿼리 실행 구조

```
쿼리 파서 → 전처리기 → 옵티마이저 → 쿼리 실행기
```

| 단계 | 역할 |
|-----|------|
| 쿼리 파서 | 쿼리 문장을 토큰으로 분리해 트리 형태 구조로 변환. 기본 문법 오류 발견 |
| 전처리기 | 파서 트리 기반으로 구조적 문제 확인. 객체 존재 여부, 접근 권한 등 확인 |
| 옵티마이저 | 저렴한 비용으로 가장 빠르게 처리할 방법 결정 |

### 실행 엔진 흐름

```
1) 실행 엔진 → (임시 테이블 생성) → 핸들러
2) 실행 엔진 → (조건에 맞는 레코드 읽기) → 핸들러
3) 실행 엔진 → (읽어온 레코드를 임시 테이블에 저장) → 핸들러
4) 실행 엔진 → (임시 테이블에서 필요한 방식으로 데이터 읽기) → 핸들러
5) 실행 엔진 → (결과) → 사용자 or 다른 모듈
```

---

### 4-1-7. 쿼리 캐시 (MySQL 8.0에서 제거됨)
- SQL 실행 결과를 메모리에 캐시, 동일 쿼리 시 즉시 결과 반환
- **단점**: 테이블 데이터 변경 시 관련 캐시 모두 삭제 필요 → 심각한 동시 처리 성능 저하

---

### 4-1-8. 스레드 풀

**목적**: 사용자 요청을 처리하는 스레드 개수를 줄여서 CPU가 제한된 개수의 스레드 처리에만 집중하게 함

**장점**
- CPU 프로세서 친화도 향상
- 불필요한 컨텍스트 스위치 감소
- 오버헤드 감소

---

### 4-1-9. 트랜잭션 지원 메타데이터

**메타데이터 (= 데이터 딕셔너리)**: 테이블 구조 정보, 스토어드 프로그램 정보 등

#### 파일 기반 메타데이터의 문제점
- 생성/변경 작업이 트랜잭션을 지원하지 않음
- 비정상 종료 시 일관성이 깨지는 문제 발생

#### MySQL 8.0 개선사항
- 메타데이터를 InnoDB 테이블에 저장
- 트랜잭션 지원으로 완전한 성공/실패 보장
- InnoDB 외 스토리지 엔진은 SDI 파일 사용

---

## 4-2. InnoDB 스토리지 엔진 아키텍처

MySQL 중 거의 유일한 **레코드 기반 잠금** 제공 → 높은 동시성, 안정성, 성능

### 4-2-1. 프라이머리 키에 의한 클러스터링
- 모든 테이블은 프라이머리 키 기준으로 클러스터링되어 저장
- MyISAM에서는 지원하지 않음

### 4-2-2. 외래 키 지원
- 부모/자식 테이블 모두 해당 컬럼에 인덱스 생성 필요
- 변경 시 데이터 존재 여부 체크로 잠금이 여러 테이블로 전파
- **데드락 발생 가능성 높음** → 개발 시 주의 필요

```sql
-- 외래키 체크 비활성화 (작업 후 일관성 맞추고 다시 활성화!)
SET foreign_key_checks=OFF;
```

> ⚠️ OFF 상태에서는 `ON DELETE CASCADE`, `ON UPDATE CASCADE` 모두 무시됨

### 4-2-3. MVCC (Multi Version Concurrency Control)
하나의 레코드에 대해 여러 개의 버전이 동시에 관리되는 것

**목적**: 잠금을 사용하지 않는 일관된 읽기 제공

InnoDB에서는 **언두 로그**를 이용해 구현

| 격리 수준 | 동작 |
|----------|------|
| READ_UNCOMMITTED | 커밋 여부 상관없이 버퍼풀에서 데이터 읽음 |
| READ_COMMITTED | 변경 전 내용을 언두 로그에 저장, 커밋될 때까지 언두 로그에서 읽음 |

### 4-2-4. 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)
- 특정 사용자가 레코드를 변경하고 아직 커밋하지 않아도 다른 사용자의 SELECT 작업을 방해하지 않음

### 4-2-5. 자동 데드락 감지
- 데드락 감지 스레드가 잠금 대기 그래프를 주기적으로 검사
- 교착 상태의 트랜잭션 중 하나를 강제 종료
- **판단 기준**: 언두 로그 양 (더 적은 쪽이 롤백 대상)

### 4-2-6. 자동화된 장애 복구

InnoDB는 MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지 등에 대한 일련의 복구 작업을 자동으로 진행한다.

- 자동으로 복구될 수 없는 손상이 있다면, 자동 복구를 멈추고 MySQL 서버 종료
- InnoDB 테이블이 인식된다면 `mysqldump`를 이용해 데이터를 백업하고 재구축하는 것이 권장됨

#### innodb_force_recovery 옵션 (1~6)

| 옵션 | 이름 | 설명 |
|-----|------|------|
| 1 | SRV_FORCE_IGNORE_CORRUPT | 테이블스페이스의 데이터/인덱스 페이지 손상 시. `mysqldump`나 `SELECT INTO OUTFILE`로 재구축 권장 |
| 2 | SRV_FORCE_NO_BACKGROUND | 메인 스레드가 언두 데이터 삭제 중 장애 발생 시 |
| 3 | SRV_FORCE_NO_TRX_UNDO | 커밋되지 않은 트랜잭션을 그 상태로 유지하며 시작. 백업 후 재구축 권장 |
| 4 | SRV_FORCE_NO_IBUF_MERGE | 인서트 버퍼 손상 시. 테이블 덤프 후 재구축하면 데이터 손실 없이 복구 가능 |
| 5 | SRV_FORCE_NO_UNDO_LOG_SCAN | 언두 로그 사용 불가 시 언두 로그를 무시하고 실행. 커밋되지 않은 작업도 커밋된 것처럼 처리됨 |
| 6 | SRV_FORCE_NO_LOG_REDO | 리두 로그 손상 시 리두 로그를 무시하고 시작. 기존 리두 로그 삭제 후 시작 권장 |

> ⚠️ 위 옵션으로도 서버가 시작되지 않을 경우, 백업과 바이너리 로그를 이용한 데이터 복구만이 방법

---

### 4-2-7. InnoDB 버퍼 풀

InnoDB 스토리지 엔진에서 **가장 핵심적인 부분**

- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할
- INSERT, UPDATE, DELETE 등 변경된 데이터를 모아서 처리 → 랜덤 디스크 작업 횟수 감소

#### 4-2-7-1. 버퍼 풀의 크기 설정

운영체제와 각 클라이언트 스레드가 사용할 메모리를 충분히 고려해서 설정

| 메모리 | 권장 설정 |
|-------|----------|
| 8GB 미만 | 50% 정도 |
| 8GB 이상 | 50%에서 시작해서 조금씩 올려 최적점 탐색 |
| 50GB 이상 | 15~30GB 정도를 운영/응용 프로그램용으로 남기고 나머지 할당 |

**버퍼 풀 인스턴스**
- 세마포어로 인한 내부 잠금 경합을 줄이기 위해 버퍼 풀을 여러 개로 분할 관리
- 기본 8개로 초기화, 1GB 미만이면 1개만 생성
- 메모리가 크다면 인스턴스당 5GB 정도 되게 설정 권장

#### 4-2-7-2. 버퍼 풀의 구조

InnoDB 스토리지 엔진은 3개의 자료 구조로 버퍼 풀 페이지를 관리

| 자료 구조 | 설명 |
|----------|------|
| 프리 리스트 | 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지 목록 |
| LRU 리스트 | LRU + MRU가 결합된 형태 (Old=LRU / New=MRU). 디스크 읽기를 최소화하기 위해 페이지를 최대한 오래 유지 |
| 플러시 리스트 | 디스크로 동기화되지 않은 더티 페이지의 변경 시점 기준 목록 |

**InnoDB에서 데이터를 찾는 과정**

1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
   - A. 어댑티브 해시 인덱스로 페이지 검색
   - B. 테이블의 인덱스(B-Tree)로 버퍼 풀에서 페이지 검색
   - C. 버퍼 풀에 있으면 해당 페이지의 포인터를 MRU 방향으로 승급
2. 디스크에서 데이터 페이지를 버퍼 풀에 적재하고 LRU 헤더에 추가
3. LRU 헤더의 페이지가 실제로 읽히면 MRU 헤더로 이동
4. 버퍼 풀에 상주하는 페이지는 접근 빈도에 따라 나이(Age) 부여, 오래 사용되지 않으면 제거 (Aging)
5. 자주 접근되는 데이터는 어댑티브 해시 인덱스에 추가

**플러시 리스트**
- 데이터 변경 시 리두 로그와 버퍼 풀의 데이터 페이지 양쪽에 변경 내용 반영
- 더티 페이지는 특정 시점이 되면 디스크로 기록

> ⚠️ 리두 로그가 디스크로 기록됐다고 해서 데이터 페이지가 디스크로 기록됐다는 것을 보장하지는 않음

#### 4-2-7-3. 버퍼 풀과 리두 로그

버퍼 풀과 리두 로그는 데이터 캐시, 쓰기 버퍼링에 있어서 매우 밀접한 관계

- 버퍼 풀 메모리만 늘리면 → 데이터 캐시 기능만 향상
- 버퍼 풀 + 리두 로그 메모리를 적절히 할당하면 → 데이터 캐시 + 쓰기 버퍼링 둘 다 향상

#### 4-2-7-4. 버퍼 풀 플러시 (Buffer Pool Flush)

더티 페이지를 성능 악영향 없이 디스크에 동기화하기 위한 2개의 플러시 기능

**1) 플러시 리스트 플러시**
- 리두 로그 공간 재활용을 위해 주기적으로 오래된 리두 로그 엔트리 공간을 비움
- 오래된 리두 로그를 지우려면 먼저 버퍼 풀의 더티 페이지가 디스크로 동기화되어야 함
- **클리너 스레드**: 더티 페이지 동기화 담당, 보통 버퍼 풀 인스턴스와 1:1로 설정

**어댑티브 플러시 알고리즘**
- 리두 로그 증가 속도를 분석해서 적절한 수준의 더티 페이지가 유지되도록 디스크 쓰기 실행
- **디스크 쓰기 폭발 현상 방지**: 더티 페이지가 90% 이상이 되면 급격히 디스크로 기록하는 현상

**2) LRU 리스트 플러시**
- 사용 빈도가 낮은 데이터 페이지를 제거해서 새로운 페이지를 읽어올 공간 확보

#### 4-2-7-5. 버퍼 풀 상태 백업 및 복구

```sql
-- MySQL 서버 셧다운 전에 버퍼 풀 상태 백업
SET GLOBAL innodb_buffer_pool_dump_now=ON;

-- MySQL 서버 재시작 후 백업된 버퍼 풀 상태 복구
SET GLOBAL innodb_buffer_pool_load_now=ON;
```

- 백업 파일: 데이터 디렉토리의 `ib_buffer_pool`
- **자동화 설정**: `innodb_buffer_pool_dump_at_shutdown`, `innodb_buffer_pool_load_at_startup`을 설정 파일에 추가

#### 4-2-7-6. 버퍼 풀의 적재 내용 확인

`information_schema.innodb_cached_indexes` 테이블에서 인덱스별 데이터 페이지 적재량 확인 가능

---

### 4-2-8. Double Write Buffer

리두 로그는 공간 낭비를 막기 위해 페이지의 변경된 내용만 기록한다. 이로 인해 더티 페이지를 디스크로 플러시할 때 일부만 기록되는 문제가 발생하면 페이지 복구가 불가능할 수 있다.

**파셜 페이지 / 톤 페이지**: 하드웨어 오작동, 시스템 비정상 종료 등으로 인해 발생

**Double-Write 기법**
- 변경 내용을 실제 데이터 파일에 기록하기 전 DoubleWrite 버퍼에 먼저 기록
- 그 후 더티 페이지를 하나씩 랜덤으로 쓰기 실행

---

### 4-2-9. 언두 로그

트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 전 버전의 데이터를 별도로 백업

| 용도 | 설명 |
|-----|------|
| 트랜잭션 보장 | 롤백 시 언두 로그에 백업된 이전 버전 데이터로 복구 |
| 격리 수준 보장 | 다른 커넥션에서 데이터 조회 시 격리 수준에 맞게 언두 로그의 데이터를 반환 |

> ⚠️ **단점**: 한 번 증가한 언두 로그 공간은 다시 줄어들지 않음

#### 4-2-9-1. 언두 테이블스페이스 관리

**언두 테이블스페이스**: 언두 로그가 저장되는 공간

- 1개 이상 128개 이하의 롤백 세그먼트 보유
- 롤백 세그먼트는 1개 이상의 언두 슬롯 보유

```
최대 동시 트랜잭션 수 = (InnoDB 페이지 크기) / 16 × (롤백 세그먼트 개수) × (언두 테이블스페이스 개수)
```

**MySQL 8.0 개선사항**: 언두 테이블스페이스를 동적으로 추가/삭제 가능

| 모드 | 설명 |
|-----|------|
| 자동 모드 | 퍼지 스레드가 주기적으로 불필요한 언두 로그 삭제 |
| 수동 모드 | 수동으로 퍼지 스레드 실행 (언두 테이블스페이스 최소 3개 필요) |

---

### 4-2-10. 체인지 버퍼

변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트하지만, 디스크에서 읽어와야 한다면 즉시 실행하지 않고 **임시 공간에 저장 후 사용자에게 결과를 먼저 반환**

이때 사용하는 임시 메모리 공간이 **체인지 버퍼**

---

### 4-2-11. 리두 로그 및 로그 버퍼

리두 로그는 트랜잭션 ACID 중 **D(Durable, 영속성)**과 가장 밀접하게 연관

- 비정상 종료 시 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치

**서버 비정상 종료 시 일관되지 않은 데이터의 종류**

| 상황 | 처리 방법 |
|-----|----------|
| 커밋됐지만 데이터 파일에 기록되지 않은 데이터 | 리두 로그에서 데이터 복사 |
| 롤백됐지만 데이터 파일에 이미 기록된 데이터 | 리두 로그에서 커밋/롤백/중간상태 확인 후 언두 또는 리두 데이터 복사 |

**로그 버퍼**
- 리두 로그 버퍼링에 사용되는 공간
- 기본값: 16MB
- BLOB, TEXT 같은 큰 데이터를 자주 변경하는 경우 더 크게 설정 권장

#### 4-2-11-1. 리두 로그 아카이빙

데이터 변경이 많아서 리두 로그가 덮어쓰인다 하더라도 백업이 실패하지 않게 해주는 **백업의 백업** 기능

- 아카이빙을 멈춰도 아카이빙 파일은 삭제되지 않음 → 수동 삭제 필요
- 아카이빙이 비정상 종료 시 아카이빙 파일은 자동 삭제

---

### 4-2-12. 어댑티브 해시 인덱스

사용자가 수동으로 생성하는 인덱스가 아닌, InnoDB 스토리지 엔진이 **자주 요청하는 데이터에 대해 자동으로 생성**하는 인덱스

- B-Tree 검색 시간을 줄여주기 위해 도입
- 자주 읽히는 데이터 페이지의 키 값으로 해시 인덱스 생성

**해시 인덱스 구조**
```
인덱스 키 값 = B-Tree 인덱스 고유번호(id) + B-Tree 인덱스의 실제 키 값
데이터 값 = 데이터 페이지 주소
```

**도움이 되는 경우**
- 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우 (디스크 읽기가 적은 경우)
- 동등 조건 검색 (동등 비교, IN 연산자)
- 쿼리가 데이터 중 일부에만 집중되는 경우

**도움이 안 되는 경우**
- 디스크 읽기가 많은 경우
- 특정 패턴의 쿼리가 많은 경우 (JOIN, LIKE 패턴 검색)
- 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우

**단점**
1. 활성화 시 필요 없더라도 계속 해시 인덱스가 사용되며, 메모리를 많이 사용
2. 데이터 삭제 시 어댑티브 해시 인덱스도 삭제 필요 → 스키마 변경 시 많은 CPU 자원 소모

---

### 4-2-13. InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교

- MySQL 8.0 이전까진 MyISAM이 많이 사용됨
- MySQL 8.0 이후 InnoDB 기능이 추가/개선되며 **InnoDB가 독점하는 추세**
- MyISAM과 MEMORY는 단순 호환성 유지 차원이며, 향후 버전에서 제거될 가능성이 높음

---

## 4-3. MyISAM 스토리지 엔진 아키텍처

### 4-3-1. 키 캐시 (= 키 버퍼)

InnoDB의 버퍼 풀과 비슷한 역할

- **인덱스만을 대상**으로 작동
- 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할 지원

> ⚠️ 기본 키 캐시 이외에 명명된 키 캐시 영역은 어떤 인덱스를 캐시할지 설정 필요

### 4-3-2. 운영체제의 캐시 및 버퍼

MyISAM 테이블의 데이터 읽기/쓰기 작업은 항상 운영체제의 디스크 읽기/쓰기 작업으로 요청됨

- 운영체제 캐시 기능으로 성능 향상 가능
- MyISAM 사용 시 **운영체제가 사용할 충분한 캐시 공간 확보** 권장

### 4-3-3. 데이터 파일과 프라이머리 키(인덱스) 구조

| 엔진 | 저장 방식 |
|-----|----------|
| InnoDB | 프라이머리 키에 의해 클러스터링되어 저장 |
| MyISAM | 프라이머리 키와 상관없이 데이터 파일이 힙 공간처럼 활용. 레코드는 ROWID라는 물리적 주소값을 가짐 |

---

## 4-4. MySQL 로그 파일

### 4-4-1. 에러 로그 파일 (log_error.err)

MySQL이 실행되는 도중에 발생하는 에러나 경고 메시지가 출력되는 로그 파일

### 4-4-2. 제너럴 쿼리 로그 파일

쿼리 로그를 활성화해서 서버에서 실행되는 쿼리 전체 목록을 검토할 때 사용

### 4-4-3. 슬로우 쿼리 로그

`long_query_time` 시스템 변수에 설정한 시간 이상 소요된 쿼리가 모두 기록

**용도**
- 서비스 운영 중 전체적인 성능 저하 검사
- 정기적인 점검을 위한 튜닝