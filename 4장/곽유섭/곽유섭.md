# 4. 아키텍처

## 4-1. MySQL 엔진 아키텍처

### 4-1-1. MySQL의 전체 구조
#### 4-1-1-1. MySQL 엔진
요청된 SQL 문장을 분석하거나 최적화하는 역할

| 구성요소 | 역할 |
|---------|------|
| 커넥션 핸들러 | 클라이언트 접속 처리 |
| SQL 파서 | 쿼리 문장 분석 |
| 전처리기 | 구조적 문제 확인 |
| 옵티마이저 | 쿼리의 최적화된 실행 |

#### 4-1-1-2. 스토리지 엔진
실제 데이터를 스토리지에 저장하거나 읽어오는 역할

- MySQL 엔진은 하나, 스토리지 엔진은 여러 개 사용 가능
- 테이블 생성 시 스토리지 엔진 지정: `CREATE TABLE ... ENGINE=INNODB;`
- 각 스토리지 엔진별 성능 향상 기능
  - **MyISAM**: 키 캐시
  - **InnoDB**: InnoDB 버퍼 풀

#### 4-1-1-3. 핸들러 API
쿼리 실행기에서 데이터를 쓰거나 읽을 때, 각 스토리지 엔진에 쓰기/읽기를 요청하는 API

---

### 4-1-2. MySQL 스레딩 구조

#### 4-1-2-1. 포그라운드 스레드 (클라이언트 스레드)
- 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
- 커넥션 종료 시 담당 스레드는 캐시로 돌아감
- 스레드 캐시에 대기 중인 스레드가 충분하면 종료

**스토리지 엔진별 차이**

| 엔진 | 처리 범위 |
|-----|----------|
| MyISAM | 디스크 쓰기 작업까지 포그라운드에서 처리 |
| InnoDB | 데이터 버퍼/캐시까지만 처리, 디스크 기록은 백그라운드 |

#### 4-1-2-2. 백그라운드 스레드
MyISAM은 해당사항 없음. InnoDB에서 처리하는 작업:

1. 인서트 버퍼 병합
2. 로그를 디스크로 기록
3. InnoDB 버퍼 풀 데이터를 디스크에 기록
4. 데이터를 버퍼로 읽기
5. 잠금/데드락 모니터링

> **핵심 원칙**: 쓰기 작업은 지연 가능, 읽기 작업은 절대 지연 불가
>
> - InnoDB: 쓰기 작업을 버퍼링해서 일괄 처리 (데이터 변경 시 파일 저장 완료를 기다리지 않아도 됨)
> - MyISAM: 쓰기 버퍼링 기능 없음

---

### 4-1-3. 메모리 할당 및 사용 구조

#### 4-1-3-1. 글로벌 메모리 영역
클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당

- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

#### 4-1-3-2. 로컬 메모리 영역 (세션 메모리 영역)
클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역

- 각 스레드별로 독립적으로 할당, **절대 공유되지 않음**

| 유형 | 버퍼 | 할당 시점 |
|-----|------|----------|
| 상시 할당 | 커넥션 버퍼, 결과 버퍼 | 커넥션이 열려있는 동안 유지 |
| 임시 할당 | 소트 버퍼, 조인 버퍼 | 쿼리 실행 순간에만 할당 후 해제 |

로컬 메모리 종류: 정렬 버퍼, 조인 버퍼, 바이너리 로그 캐시, 네트워크 버퍼

---

### 4-1-4. 플러그인 스토리지 엔진 모델

- 마지막 '데이터 읽기/쓰기' 작업만 처리
- MySQL 엔진이 스토리지 엔진에게 명령하려면 **반드시 핸들러를 통해야 함**

> ⚠️ **중요**: 하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데, 각 하위 작업이 MySQL 엔진 영역에서 처리되는지 스토리지 엔진 영역에서 처리되는지 구분할 줄 알아야 한다.

---

### 4-1-5. 컴포넌트 (MySQL 8.0+)
기존 플러그인 아키텍처를 대체

**플러그인의 단점**
1. 플러그인은 오직 MySQL 서버와만 인터페이스 가능, 플러그인끼리 통신 불가
2. MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음
3. 상호 의존 관계를 설정할 수 없어서 초기화가 어려움

---

### 4-1-6. 쿼리 실행 구조

```
쿼리 파서 → 전처리기 → 옵티마이저 → 쿼리 실행기
```

| 단계 | 역할 |
|-----|------|
| 쿼리 파서 | 쿼리 문장을 토큰으로 분리해 트리 형태 구조로 변환. 기본 문법 오류 발견 |
| 전처리기 | 파서 트리 기반으로 구조적 문제 확인. 객체 존재 여부, 접근 권한 등 확인 |
| 옵티마이저 | 저렴한 비용으로 가장 빠르게 처리할 방법 결정 |

### 실행 엔진 흐름

```
1) 실행 엔진 → (임시 테이블 생성) → 핸들러
2) 실행 엔진 → (조건에 맞는 레코드 읽기) → 핸들러
3) 실행 엔진 → (읽어온 레코드를 임시 테이블에 저장) → 핸들러
4) 실행 엔진 → (임시 테이블에서 필요한 방식으로 데이터 읽기) → 핸들러
5) 실행 엔진 → (결과) → 사용자 or 다른 모듈
```

---

### 4-1-7. 쿼리 캐시 (MySQL 8.0에서 제거됨)
- SQL 실행 결과를 메모리에 캐시, 동일 쿼리 시 즉시 결과 반환
- **단점**: 테이블 데이터 변경 시 관련 캐시 모두 삭제 필요 → 심각한 동시 처리 성능 저하

---

### 4-1-8. 스레드 풀

**목적**: 사용자 요청을 처리하는 스레드 개수를 줄여서 CPU가 제한된 개수의 스레드 처리에만 집중하게 함

**장점**
- CPU 프로세서 친화도 향상
- 불필요한 컨텍스트 스위치 감소
- 오버헤드 감소

---

### 4-1-9. 트랜잭션 지원 메타데이터

**메타데이터 (= 데이터 딕셔너리)**: 테이블 구조 정보, 스토어드 프로그램 정보 등

#### 파일 기반 메타데이터의 문제점
- 생성/변경 작업이 트랜잭션을 지원하지 않음
- 비정상 종료 시 일관성이 깨지는 문제 발생

#### MySQL 8.0 개선사항
- 메타데이터를 InnoDB 테이블에 저장
- 트랜잭션 지원으로 완전한 성공/실패 보장
- InnoDB 외 스토리지 엔진은 SDI 파일 사용

---

## 4-2. InnoDB 스토리지 엔진 아키텍처

MySQL 중 거의 유일한 **레코드 기반 잠금** 제공 → 높은 동시성, 안정성, 성능

### 4-2-1. 프라이머리 키에 의한 클러스터링
- 모든 테이블은 프라이머리 키 기준으로 클러스터링되어 저장
- MyISAM에서는 지원하지 않음

### 4-2-2. 외래 키 지원
- 부모/자식 테이블 모두 해당 컬럼에 인덱스 생성 필요
- 변경 시 데이터 존재 여부 체크로 잠금이 여러 테이블로 전파
- **데드락 발생 가능성 높음** → 개발 시 주의 필요

```sql
-- 외래키 체크 비활성화 (작업 후 일관성 맞추고 다시 활성화!)
SET foreign_key_checks=OFF;
```

> ⚠️ OFF 상태에서는 `ON DELETE CASCADE`, `ON UPDATE CASCADE` 모두 무시됨

### 4-2-3. MVCC (Multi Version Concurrency Control)
하나의 레코드에 대해 여러 개의 버전이 동시에 관리되는 것

**목적**: 잠금을 사용하지 않는 일관된 읽기 제공

InnoDB에서는 **언두 로그**를 이용해 구현

| 격리 수준 | 동작 |
|----------|------|
| READ_UNCOMMITTED | 커밋 여부 상관없이 버퍼풀에서 데이터 읽음 |
| READ_COMMITTED | 변경 전 내용을 언두 로그에 저장, 커밋될 때까지 언두 로그에서 읽음 |

### 4-2-4. 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)
- 특정 사용자가 레코드를 변경하고 아직 커밋하지 않아도 다른 사용자의 SELECT 작업을 방해하지 않음

### 4-2-5. 자동 데드락 감지
- 데드락 감지 스레드가 잠금 대기 그래프를 주기적으로 검사
- 교착 상태의 트랜잭션 중 하나를 강제 종료
- **판단 기준**: 언두 로그 양 (더 적은 쪽이 롤백 대상)

### 4-2-6. 자동화된 장애 복구
